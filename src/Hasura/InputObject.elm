-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (Follow_connection_aggregate_order_by, Follow_connection_aggregate_order_byOptionalFields, Follow_connection_arr_rel_insert_input(..), Follow_connection_arr_rel_insert_inputOptionalFields, Follow_connection_arr_rel_insert_inputRaw, Follow_connection_arr_rel_insert_inputRequiredFields, Follow_connection_bool_exp(..), Follow_connection_bool_expOptionalFields, Follow_connection_bool_expRaw, Follow_connection_insert_input(..), Follow_connection_insert_inputOptionalFields, Follow_connection_insert_inputRaw, Follow_connection_max_order_by, Follow_connection_max_order_byOptionalFields, Follow_connection_min_order_by, Follow_connection_min_order_byOptionalFields, Follow_connection_obj_rel_insert_input(..), Follow_connection_obj_rel_insert_inputOptionalFields, Follow_connection_obj_rel_insert_inputRaw, Follow_connection_obj_rel_insert_inputRequiredFields, Follow_connection_on_conflict, Follow_connection_on_conflictRequiredFields, Follow_connection_order_by(..), Follow_connection_order_byOptionalFields, Follow_connection_order_byRaw, Follow_connection_set_input, Follow_connection_set_inputOptionalFields, Integer_comparison_exp, Integer_comparison_expOptionalFields, Text_comparison_exp, Text_comparison_expOptionalFields, Timestamptz_comparison_exp, Timestamptz_comparison_expOptionalFields, User_aggregate_order_by, User_aggregate_order_byOptionalFields, User_arr_rel_insert_input(..), User_arr_rel_insert_inputOptionalFields, User_arr_rel_insert_inputRaw, User_arr_rel_insert_inputRequiredFields, User_avg_order_by, User_avg_order_byOptionalFields, User_bool_exp(..), User_bool_expOptionalFields, User_bool_expRaw, User_inc_input, User_inc_inputOptionalFields, User_insert_input(..), User_insert_inputOptionalFields, User_insert_inputRaw, User_max_order_by, User_max_order_byOptionalFields, User_min_order_by, User_min_order_byOptionalFields, User_obj_rel_insert_input(..), User_obj_rel_insert_inputOptionalFields, User_obj_rel_insert_inputRaw, User_obj_rel_insert_inputRequiredFields, User_on_conflict, User_on_conflictRequiredFields, User_order_by(..), User_order_byOptionalFields, User_order_byRaw, User_set_input, User_set_inputOptionalFields, User_stddev_order_by, User_stddev_order_byOptionalFields, User_stddev_pop_order_by, User_stddev_pop_order_byOptionalFields, User_stddev_samp_order_by, User_stddev_samp_order_byOptionalFields, User_sum_order_by, User_sum_order_byOptionalFields, User_var_pop_order_by, User_var_pop_order_byOptionalFields, User_var_samp_order_by, User_var_samp_order_byOptionalFields, User_variance_order_by, User_variance_order_byOptionalFields, Uuid_comparison_exp, Uuid_comparison_expOptionalFields, buildFollow_connection_aggregate_order_by, buildFollow_connection_arr_rel_insert_input, buildFollow_connection_bool_exp, buildFollow_connection_insert_input, buildFollow_connection_max_order_by, buildFollow_connection_min_order_by, buildFollow_connection_obj_rel_insert_input, buildFollow_connection_on_conflict, buildFollow_connection_order_by, buildFollow_connection_set_input, buildInteger_comparison_exp, buildText_comparison_exp, buildTimestamptz_comparison_exp, buildUser_aggregate_order_by, buildUser_arr_rel_insert_input, buildUser_avg_order_by, buildUser_bool_exp, buildUser_inc_input, buildUser_insert_input, buildUser_max_order_by, buildUser_min_order_by, buildUser_obj_rel_insert_input, buildUser_on_conflict, buildUser_order_by, buildUser_set_input, buildUser_stddev_order_by, buildUser_stddev_pop_order_by, buildUser_stddev_samp_order_by, buildUser_sum_order_by, buildUser_var_pop_order_by, buildUser_var_samp_order_by, buildUser_variance_order_by, buildUuid_comparison_exp, encodeFollow_connection_aggregate_order_by, encodeFollow_connection_arr_rel_insert_input, encodeFollow_connection_bool_exp, encodeFollow_connection_insert_input, encodeFollow_connection_max_order_by, encodeFollow_connection_min_order_by, encodeFollow_connection_obj_rel_insert_input, encodeFollow_connection_on_conflict, encodeFollow_connection_order_by, encodeFollow_connection_set_input, encodeInteger_comparison_exp, encodeText_comparison_exp, encodeTimestamptz_comparison_exp, encodeUser_aggregate_order_by, encodeUser_arr_rel_insert_input, encodeUser_avg_order_by, encodeUser_bool_exp, encodeUser_inc_input, encodeUser_insert_input, encodeUser_max_order_by, encodeUser_min_order_by, encodeUser_obj_rel_insert_input, encodeUser_on_conflict, encodeUser_order_by, encodeUser_set_input, encodeUser_stddev_order_by, encodeUser_stddev_pop_order_by, encodeUser_stddev_samp_order_by, encodeUser_sum_order_by, encodeUser_var_pop_order_by, encodeUser_var_samp_order_by, encodeUser_variance_order_by, encodeUuid_comparison_exp)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Follow_connection_constraint
import Hasura.Enum.Follow_connection_update_column
import Hasura.Enum.Order_by
import Hasura.Enum.User_constraint
import Hasura.Enum.User_update_column
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildFollow_connection_aggregate_order_by : (Follow_connection_aggregate_order_byOptionalFields -> Follow_connection_aggregate_order_byOptionalFields) -> Follow_connection_aggregate_order_by
buildFollow_connection_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { count = Absent, max = Absent, min = Absent }
    in
    { count = optionals.count, max = optionals.max, min = optionals.min }


type alias Follow_connection_aggregate_order_byOptionalFields =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Follow_connection_max_order_by
    , min : OptionalArgument Follow_connection_min_order_by
    }


{-| Type for the Follow\_connection\_aggregate\_order\_by input object.
-}
type alias Follow_connection_aggregate_order_by =
    { count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument Follow_connection_max_order_by
    , min : OptionalArgument Follow_connection_min_order_by
    }


{-| Encode a Follow\_connection\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeFollow_connection_aggregate_order_by : Follow_connection_aggregate_order_by -> Value
encodeFollow_connection_aggregate_order_by input =
    Encode.maybeObject
        [ ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeFollow_connection_max_order_by |> Encode.optional input.max ), ( "min", encodeFollow_connection_min_order_by |> Encode.optional input.min ) ]


buildFollow_connection_arr_rel_insert_input : Follow_connection_arr_rel_insert_inputRequiredFields -> (Follow_connection_arr_rel_insert_inputOptionalFields -> Follow_connection_arr_rel_insert_inputOptionalFields) -> Follow_connection_arr_rel_insert_input
buildFollow_connection_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Follow_connection_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Follow_connection_arr_rel_insert_inputRequiredFields =
    { data : List Follow_connection_insert_input }


type alias Follow_connection_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Follow_connection_on_conflict }


{-| Type alias for the `Follow_connection_arr_rel_insert_input` attributes. Note that this type
needs to use the `Follow_connection_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follow_connection_arr_rel_insert_inputRaw =
    { data : List Follow_connection_insert_input
    , on_conflict : OptionalArgument Follow_connection_on_conflict
    }


{-| Type for the Follow\_connection\_arr\_rel\_insert\_input input object.
-}
type Follow_connection_arr_rel_insert_input
    = Follow_connection_arr_rel_insert_input Follow_connection_arr_rel_insert_inputRaw


{-| Encode a Follow\_connection\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeFollow_connection_arr_rel_insert_input : Follow_connection_arr_rel_insert_input -> Value
encodeFollow_connection_arr_rel_insert_input (Follow_connection_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeFollow_connection_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeFollow_connection_on_conflict |> Encode.optional input.on_conflict ) ]


buildFollow_connection_bool_exp : (Follow_connection_bool_expOptionalFields -> Follow_connection_bool_expOptionalFields) -> Follow_connection_bool_exp
buildFollow_connection_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, created = Absent, followed_user = Absent, followed_user_id = Absent, follower = Absent, follower_id = Absent, id = Absent }
    in
    Follow_connection_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, created = optionals.created, followed_user = optionals.followed_user, followed_user_id = optionals.followed_user_id, follower = optionals.follower, follower_id = optionals.follower_id, id = optionals.id }


type alias Follow_connection_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Follow_connection_bool_exp))
    , not_ : OptionalArgument Follow_connection_bool_exp
    , or_ : OptionalArgument (List (Maybe Follow_connection_bool_exp))
    , created : OptionalArgument Timestamptz_comparison_exp
    , followed_user : OptionalArgument User_bool_exp
    , followed_user_id : OptionalArgument Uuid_comparison_exp
    , follower : OptionalArgument User_bool_exp
    , follower_id : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    }


{-| Type alias for the `Follow_connection_bool_exp` attributes. Note that this type
needs to use the `Follow_connection_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follow_connection_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Follow_connection_bool_exp))
    , not_ : OptionalArgument Follow_connection_bool_exp
    , or_ : OptionalArgument (List (Maybe Follow_connection_bool_exp))
    , created : OptionalArgument Timestamptz_comparison_exp
    , followed_user : OptionalArgument User_bool_exp
    , followed_user_id : OptionalArgument Uuid_comparison_exp
    , follower : OptionalArgument User_bool_exp
    , follower_id : OptionalArgument Uuid_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    }


{-| Type for the Follow\_connection\_bool\_exp input object.
-}
type Follow_connection_bool_exp
    = Follow_connection_bool_exp Follow_connection_bool_expRaw


{-| Encode a Follow\_connection\_bool\_exp into a value that can be used as an argument.
-}
encodeFollow_connection_bool_exp : Follow_connection_bool_exp -> Value
encodeFollow_connection_bool_exp (Follow_connection_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeFollow_connection_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeFollow_connection_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeFollow_connection_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "created", encodeTimestamptz_comparison_exp |> Encode.optional input.created ), ( "followed_user", encodeUser_bool_exp |> Encode.optional input.followed_user ), ( "followed_user_id", encodeUuid_comparison_exp |> Encode.optional input.followed_user_id ), ( "follower", encodeUser_bool_exp |> Encode.optional input.follower ), ( "follower_id", encodeUuid_comparison_exp |> Encode.optional input.follower_id ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ) ]


buildFollow_connection_insert_input : (Follow_connection_insert_inputOptionalFields -> Follow_connection_insert_inputOptionalFields) -> Follow_connection_insert_input
buildFollow_connection_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created = Absent, followed_user = Absent, followed_user_id = Absent, follower = Absent, follower_id = Absent, id = Absent }
    in
    Follow_connection_insert_input { created = optionals.created, followed_user = optionals.followed_user, followed_user_id = optionals.followed_user_id, follower = optionals.follower, follower_id = optionals.follower_id, id = optionals.id }


type alias Follow_connection_insert_inputOptionalFields =
    { created : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , followed_user : OptionalArgument User_obj_rel_insert_input
    , followed_user_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , follower : OptionalArgument User_obj_rel_insert_input
    , follower_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    }


{-| Type alias for the `Follow_connection_insert_input` attributes. Note that this type
needs to use the `Follow_connection_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follow_connection_insert_inputRaw =
    { created : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , followed_user : OptionalArgument User_obj_rel_insert_input
    , followed_user_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , follower : OptionalArgument User_obj_rel_insert_input
    , follower_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    }


{-| Type for the Follow\_connection\_insert\_input input object.
-}
type Follow_connection_insert_input
    = Follow_connection_insert_input Follow_connection_insert_inputRaw


{-| Encode a Follow\_connection\_insert\_input into a value that can be used as an argument.
-}
encodeFollow_connection_insert_input : Follow_connection_insert_input -> Value
encodeFollow_connection_insert_input (Follow_connection_insert_input input) =
    Encode.maybeObject
        [ ( "created", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created ), ( "followed_user", encodeUser_obj_rel_insert_input |> Encode.optional input.followed_user ), ( "followed_user_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.followed_user_id ), ( "follower", encodeUser_obj_rel_insert_input |> Encode.optional input.follower ), ( "follower_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.follower_id ), ( "id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ) ]


buildFollow_connection_max_order_by : (Follow_connection_max_order_byOptionalFields -> Follow_connection_max_order_byOptionalFields) -> Follow_connection_max_order_by
buildFollow_connection_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created = Absent }
    in
    { created = optionals.created }


type alias Follow_connection_max_order_byOptionalFields =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Follow\_connection\_max\_order\_by input object.
-}
type alias Follow_connection_max_order_by =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Follow\_connection\_max\_order\_by into a value that can be used as an argument.
-}
encodeFollow_connection_max_order_by : Follow_connection_max_order_by -> Value
encodeFollow_connection_max_order_by input =
    Encode.maybeObject
        [ ( "created", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created ) ]


buildFollow_connection_min_order_by : (Follow_connection_min_order_byOptionalFields -> Follow_connection_min_order_byOptionalFields) -> Follow_connection_min_order_by
buildFollow_connection_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created = Absent }
    in
    { created = optionals.created }


type alias Follow_connection_min_order_byOptionalFields =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the Follow\_connection\_min\_order\_by input object.
-}
type alias Follow_connection_min_order_by =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a Follow\_connection\_min\_order\_by into a value that can be used as an argument.
-}
encodeFollow_connection_min_order_by : Follow_connection_min_order_by -> Value
encodeFollow_connection_min_order_by input =
    Encode.maybeObject
        [ ( "created", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created ) ]


buildFollow_connection_obj_rel_insert_input : Follow_connection_obj_rel_insert_inputRequiredFields -> (Follow_connection_obj_rel_insert_inputOptionalFields -> Follow_connection_obj_rel_insert_inputOptionalFields) -> Follow_connection_obj_rel_insert_input
buildFollow_connection_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Follow_connection_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Follow_connection_obj_rel_insert_inputRequiredFields =
    { data : Follow_connection_insert_input }


type alias Follow_connection_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Follow_connection_on_conflict }


{-| Type alias for the `Follow_connection_obj_rel_insert_input` attributes. Note that this type
needs to use the `Follow_connection_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follow_connection_obj_rel_insert_inputRaw =
    { data : Follow_connection_insert_input
    , on_conflict : OptionalArgument Follow_connection_on_conflict
    }


{-| Type for the Follow\_connection\_obj\_rel\_insert\_input input object.
-}
type Follow_connection_obj_rel_insert_input
    = Follow_connection_obj_rel_insert_input Follow_connection_obj_rel_insert_inputRaw


{-| Encode a Follow\_connection\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeFollow_connection_obj_rel_insert_input : Follow_connection_obj_rel_insert_input -> Value
encodeFollow_connection_obj_rel_insert_input (Follow_connection_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeFollow_connection_insert_input input.data |> Just ), ( "on_conflict", encodeFollow_connection_on_conflict |> Encode.optional input.on_conflict ) ]


buildFollow_connection_on_conflict : Follow_connection_on_conflictRequiredFields -> Follow_connection_on_conflict
buildFollow_connection_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Follow_connection_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Follow_connection_constraint.Follow_connection_constraint
    , update_columns : List Hasura.Enum.Follow_connection_update_column.Follow_connection_update_column
    }


{-| Type for the Follow\_connection\_on\_conflict input object.
-}
type alias Follow_connection_on_conflict =
    { constraint : Hasura.Enum.Follow_connection_constraint.Follow_connection_constraint
    , update_columns : List Hasura.Enum.Follow_connection_update_column.Follow_connection_update_column
    }


{-| Encode a Follow\_connection\_on\_conflict into a value that can be used as an argument.
-}
encodeFollow_connection_on_conflict : Follow_connection_on_conflict -> Value
encodeFollow_connection_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Follow_connection_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Follow_connection_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildFollow_connection_order_by : (Follow_connection_order_byOptionalFields -> Follow_connection_order_byOptionalFields) -> Follow_connection_order_by
buildFollow_connection_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created = Absent, followed_user = Absent, followed_user_id = Absent, follower = Absent, follower_id = Absent, id = Absent }
    in
    Follow_connection_order_by { created = optionals.created, followed_user = optionals.followed_user, followed_user_id = optionals.followed_user_id, follower = optionals.follower, follower_id = optionals.follower_id, id = optionals.id }


type alias Follow_connection_order_byOptionalFields =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by
    , followed_user : OptionalArgument User_order_by
    , followed_user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , follower : OptionalArgument User_order_by
    , follower_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type alias for the `Follow_connection_order_by` attributes. Note that this type
needs to use the `Follow_connection_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Follow_connection_order_byRaw =
    { created : OptionalArgument Hasura.Enum.Order_by.Order_by
    , followed_user : OptionalArgument User_order_by
    , followed_user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , follower : OptionalArgument User_order_by
    , follower_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Follow\_connection\_order\_by input object.
-}
type Follow_connection_order_by
    = Follow_connection_order_by Follow_connection_order_byRaw


{-| Encode a Follow\_connection\_order\_by into a value that can be used as an argument.
-}
encodeFollow_connection_order_by : Follow_connection_order_by -> Value
encodeFollow_connection_order_by (Follow_connection_order_by input) =
    Encode.maybeObject
        [ ( "created", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created ), ( "followed_user", encodeUser_order_by |> Encode.optional input.followed_user ), ( "followed_user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.followed_user_id ), ( "follower", encodeUser_order_by |> Encode.optional input.follower ), ( "follower_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.follower_id ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildFollow_connection_set_input : (Follow_connection_set_inputOptionalFields -> Follow_connection_set_inputOptionalFields) -> Follow_connection_set_input
buildFollow_connection_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { created = Absent, followed_user_id = Absent, follower_id = Absent, id = Absent }
    in
    { created = optionals.created, followed_user_id = optionals.followed_user_id, follower_id = optionals.follower_id, id = optionals.id }


type alias Follow_connection_set_inputOptionalFields =
    { created : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , followed_user_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , follower_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    }


{-| Type for the Follow\_connection\_set\_input input object.
-}
type alias Follow_connection_set_input =
    { created : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , followed_user_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , follower_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    }


{-| Encode a Follow\_connection\_set\_input into a value that can be used as an argument.
-}
encodeFollow_connection_set_input : Follow_connection_set_input -> Value
encodeFollow_connection_set_input input =
    Encode.maybeObject
        [ ( "created", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.created ), ( "followed_user_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.followed_user_id ), ( "follower_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.follower_id ), ( "id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ) ]


buildInteger_comparison_exp : (Integer_comparison_expOptionalFields -> Integer_comparison_expOptionalFields) -> Integer_comparison_exp
buildInteger_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Integer_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Integer\_comparison\_exp input object.
-}
type alias Integer_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Integer\_comparison\_exp into a value that can be used as an argument.
-}
encodeInteger_comparison_exp : Integer_comparison_exp -> Value
encodeInteger_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildText_comparison_exp : (Text_comparison_expOptionalFields -> Text_comparison_expOptionalFields) -> Text_comparison_exp
buildText_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias Text_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the Text\_comparison\_exp input object.
-}
type alias Text_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a Text\_comparison\_exp into a value that can be used as an argument.
-}
encodeText_comparison_exp : Text_comparison_exp -> Value
encodeText_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Timestamptz)
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildUser_aggregate_order_by : (User_aggregate_order_byOptionalFields -> User_aggregate_order_byOptionalFields) -> User_aggregate_order_by
buildUser_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias User_aggregate_order_byOptionalFields =
    { avg : OptionalArgument User_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    , stddev : OptionalArgument User_stddev_order_by
    , stddev_pop : OptionalArgument User_stddev_pop_order_by
    , stddev_samp : OptionalArgument User_stddev_samp_order_by
    , sum : OptionalArgument User_sum_order_by
    , var_pop : OptionalArgument User_var_pop_order_by
    , var_samp : OptionalArgument User_var_samp_order_by
    , variance : OptionalArgument User_variance_order_by
    }


{-| Type for the User\_aggregate\_order\_by input object.
-}
type alias User_aggregate_order_by =
    { avg : OptionalArgument User_avg_order_by
    , count : OptionalArgument Hasura.Enum.Order_by.Order_by
    , max : OptionalArgument User_max_order_by
    , min : OptionalArgument User_min_order_by
    , stddev : OptionalArgument User_stddev_order_by
    , stddev_pop : OptionalArgument User_stddev_pop_order_by
    , stddev_samp : OptionalArgument User_stddev_samp_order_by
    , sum : OptionalArgument User_sum_order_by
    , var_pop : OptionalArgument User_var_pop_order_by
    , var_samp : OptionalArgument User_var_samp_order_by
    , variance : OptionalArgument User_variance_order_by
    }


{-| Encode a User\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeUser_aggregate_order_by : User_aggregate_order_by -> Value
encodeUser_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeUser_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeUser_max_order_by |> Encode.optional input.max ), ( "min", encodeUser_min_order_by |> Encode.optional input.min ), ( "stddev", encodeUser_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeUser_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeUser_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeUser_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeUser_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeUser_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeUser_variance_order_by |> Encode.optional input.variance ) ]


buildUser_arr_rel_insert_input : User_arr_rel_insert_inputRequiredFields -> (User_arr_rel_insert_inputOptionalFields -> User_arr_rel_insert_inputOptionalFields) -> User_arr_rel_insert_input
buildUser_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_arr_rel_insert_inputRequiredFields =
    { data : List User_insert_input }


type alias User_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_arr_rel_insert_input` attributes. Note that this type
needs to use the `User_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_arr_rel_insert_inputRaw =
    { data : List User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_arr\_rel\_insert\_input input object.
-}
type User_arr_rel_insert_input
    = User_arr_rel_insert_input User_arr_rel_insert_inputRaw


{-| Encode a User\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_arr_rel_insert_input : User_arr_rel_insert_input -> Value
encodeUser_arr_rel_insert_input (User_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeUser_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_avg_order_by : (User_avg_order_byOptionalFields -> User_avg_order_byOptionalFields) -> User_avg_order_by
buildUser_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_avg_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_avg\_order\_by input object.
-}
type alias User_avg_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_avg\_order\_by into a value that can be used as an argument.
-}
encodeUser_avg_order_by : User_avg_order_by -> Value
encodeUser_avg_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_bool_exp : (User_bool_expOptionalFields -> User_bool_expOptionalFields) -> User_bool_exp
buildUser_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, age = Absent, followed_users = Absent, followers = Absent, id = Absent, inviter = Absent, inviter_id = Absent, name = Absent }
    in
    User_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, age = optionals.age, followed_users = optionals.followed_users, followers = optionals.followers, id = optionals.id, inviter = optionals.inviter, inviter_id = optionals.inviter_id, name = optionals.name }


type alias User_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , age : OptionalArgument Integer_comparison_exp
    , followed_users : OptionalArgument Follow_connection_bool_exp
    , followers : OptionalArgument Follow_connection_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , inviter : OptionalArgument User_bool_exp
    , inviter_id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    }


{-| Type alias for the `User_bool_exp` attributes. Note that this type
needs to use the `User_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe User_bool_exp))
    , not_ : OptionalArgument User_bool_exp
    , or_ : OptionalArgument (List (Maybe User_bool_exp))
    , age : OptionalArgument Integer_comparison_exp
    , followed_users : OptionalArgument Follow_connection_bool_exp
    , followers : OptionalArgument Follow_connection_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , inviter : OptionalArgument User_bool_exp
    , inviter_id : OptionalArgument Uuid_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    }


{-| Type for the User\_bool\_exp input object.
-}
type User_bool_exp
    = User_bool_exp User_bool_expRaw


{-| Encode a User\_bool\_exp into a value that can be used as an argument.
-}
encodeUser_bool_exp : User_bool_exp -> Value
encodeUser_bool_exp (User_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUser_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUser_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "age", encodeInteger_comparison_exp |> Encode.optional input.age ), ( "followed_users", encodeFollow_connection_bool_exp |> Encode.optional input.followed_users ), ( "followers", encodeFollow_connection_bool_exp |> Encode.optional input.followers ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "inviter", encodeUser_bool_exp |> Encode.optional input.inviter ), ( "inviter_id", encodeUuid_comparison_exp |> Encode.optional input.inviter_id ), ( "name", encodeText_comparison_exp |> Encode.optional input.name ) ]


buildUser_inc_input : (User_inc_inputOptionalFields -> User_inc_inputOptionalFields) -> User_inc_input
buildUser_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_inc_inputOptionalFields =
    { age : OptionalArgument Int }


{-| Type for the User\_inc\_input input object.
-}
type alias User_inc_input =
    { age : OptionalArgument Int }


{-| Encode a User\_inc\_input into a value that can be used as an argument.
-}
encodeUser_inc_input : User_inc_input -> Value
encodeUser_inc_input input =
    Encode.maybeObject
        [ ( "age", Encode.int |> Encode.optional input.age ) ]


buildUser_insert_input : (User_insert_inputOptionalFields -> User_insert_inputOptionalFields) -> User_insert_input
buildUser_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent, followed_users = Absent, followers = Absent, id = Absent, inviter = Absent, inviter_id = Absent, name = Absent }
    in
    User_insert_input { age = optionals.age, followed_users = optionals.followed_users, followers = optionals.followers, id = optionals.id, inviter = optionals.inviter, inviter_id = optionals.inviter_id, name = optionals.name }


type alias User_insert_inputOptionalFields =
    { age : OptionalArgument Int
    , followed_users : OptionalArgument Follow_connection_arr_rel_insert_input
    , followers : OptionalArgument Follow_connection_arr_rel_insert_input
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , inviter : OptionalArgument User_obj_rel_insert_input
    , inviter_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , name : OptionalArgument String
    }


{-| Type alias for the `User_insert_input` attributes. Note that this type
needs to use the `User_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_insert_inputRaw =
    { age : OptionalArgument Int
    , followed_users : OptionalArgument Follow_connection_arr_rel_insert_input
    , followers : OptionalArgument Follow_connection_arr_rel_insert_input
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , inviter : OptionalArgument User_obj_rel_insert_input
    , inviter_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , name : OptionalArgument String
    }


{-| Type for the User\_insert\_input input object.
-}
type User_insert_input
    = User_insert_input User_insert_inputRaw


{-| Encode a User\_insert\_input into a value that can be used as an argument.
-}
encodeUser_insert_input : User_insert_input -> Value
encodeUser_insert_input (User_insert_input input) =
    Encode.maybeObject
        [ ( "age", Encode.int |> Encode.optional input.age ), ( "followed_users", encodeFollow_connection_arr_rel_insert_input |> Encode.optional input.followed_users ), ( "followers", encodeFollow_connection_arr_rel_insert_input |> Encode.optional input.followers ), ( "id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "inviter", encodeUser_obj_rel_insert_input |> Encode.optional input.inviter ), ( "inviter_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.inviter_id ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildUser_max_order_by : (User_max_order_byOptionalFields -> User_max_order_byOptionalFields) -> User_max_order_by
buildUser_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent, name = Absent }
    in
    { age = optionals.age, name = optionals.name }


type alias User_max_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the User\_max\_order\_by input object.
-}
type alias User_max_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a User\_max\_order\_by into a value that can be used as an argument.
-}
encodeUser_max_order_by : User_max_order_by -> Value
encodeUser_max_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildUser_min_order_by : (User_min_order_byOptionalFields -> User_min_order_byOptionalFields) -> User_min_order_by
buildUser_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent, name = Absent }
    in
    { age = optionals.age, name = optionals.name }


type alias User_min_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the User\_min\_order\_by input object.
-}
type alias User_min_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a User\_min\_order\_by into a value that can be used as an argument.
-}
encodeUser_min_order_by : User_min_order_by -> Value
encodeUser_min_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildUser_obj_rel_insert_input : User_obj_rel_insert_inputRequiredFields -> (User_obj_rel_insert_inputOptionalFields -> User_obj_rel_insert_inputOptionalFields) -> User_obj_rel_insert_input
buildUser_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    User_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias User_obj_rel_insert_inputRequiredFields =
    { data : User_insert_input }


type alias User_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument User_on_conflict }


{-| Type alias for the `User_obj_rel_insert_input` attributes. Note that this type
needs to use the `User_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_obj_rel_insert_inputRaw =
    { data : User_insert_input
    , on_conflict : OptionalArgument User_on_conflict
    }


{-| Type for the User\_obj\_rel\_insert\_input input object.
-}
type User_obj_rel_insert_input
    = User_obj_rel_insert_input User_obj_rel_insert_inputRaw


{-| Encode a User\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeUser_obj_rel_insert_input : User_obj_rel_insert_input -> Value
encodeUser_obj_rel_insert_input (User_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeUser_insert_input input.data |> Just ), ( "on_conflict", encodeUser_on_conflict |> Encode.optional input.on_conflict ) ]


buildUser_on_conflict : User_on_conflictRequiredFields -> User_on_conflict
buildUser_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias User_on_conflictRequiredFields =
    { constraint : Hasura.Enum.User_constraint.User_constraint
    , update_columns : List Hasura.Enum.User_update_column.User_update_column
    }


{-| Type for the User\_on\_conflict input object.
-}
type alias User_on_conflict =
    { constraint : Hasura.Enum.User_constraint.User_constraint
    , update_columns : List Hasura.Enum.User_update_column.User_update_column
    }


{-| Encode a User\_on\_conflict into a value that can be used as an argument.
-}
encodeUser_on_conflict : User_on_conflict -> Value
encodeUser_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.User_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.User_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildUser_order_by : (User_order_byOptionalFields -> User_order_byOptionalFields) -> User_order_by
buildUser_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent, followed_users_aggregate = Absent, followers_aggregate = Absent, id = Absent, inviter = Absent, inviter_id = Absent, name = Absent }
    in
    User_order_by { age = optionals.age, followed_users_aggregate = optionals.followed_users_aggregate, followers_aggregate = optionals.followers_aggregate, id = optionals.id, inviter = optionals.inviter, inviter_id = optionals.inviter_id, name = optionals.name }


type alias User_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , followed_users_aggregate : OptionalArgument Follow_connection_aggregate_order_by
    , followers_aggregate : OptionalArgument Follow_connection_aggregate_order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , inviter : OptionalArgument User_order_by
    , inviter_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type alias for the `User_order_by` attributes. Note that this type
needs to use the `User_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias User_order_byRaw =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by
    , followed_users_aggregate : OptionalArgument Follow_connection_aggregate_order_by
    , followers_aggregate : OptionalArgument Follow_connection_aggregate_order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , inviter : OptionalArgument User_order_by
    , inviter_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the User\_order\_by input object.
-}
type User_order_by
    = User_order_by User_order_byRaw


{-| Encode a User\_order\_by into a value that can be used as an argument.
-}
encodeUser_order_by : User_order_by -> Value
encodeUser_order_by (User_order_by input) =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ), ( "followed_users_aggregate", encodeFollow_connection_aggregate_order_by |> Encode.optional input.followed_users_aggregate ), ( "followers_aggregate", encodeFollow_connection_aggregate_order_by |> Encode.optional input.followers_aggregate ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "inviter", encodeUser_order_by |> Encode.optional input.inviter ), ( "inviter_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.inviter_id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildUser_set_input : (User_set_inputOptionalFields -> User_set_inputOptionalFields) -> User_set_input
buildUser_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent, id = Absent, inviter_id = Absent, name = Absent }
    in
    { age = optionals.age, id = optionals.id, inviter_id = optionals.inviter_id, name = optionals.name }


type alias User_set_inputOptionalFields =
    { age : OptionalArgument Int
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , inviter_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , name : OptionalArgument String
    }


{-| Type for the User\_set\_input input object.
-}
type alias User_set_input =
    { age : OptionalArgument Int
    , id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , inviter_id : OptionalArgument Hasura.ScalarCodecs.Uuid
    , name : OptionalArgument String
    }


{-| Encode a User\_set\_input into a value that can be used as an argument.
-}
encodeUser_set_input : User_set_input -> Value
encodeUser_set_input input =
    Encode.maybeObject
        [ ( "age", Encode.int |> Encode.optional input.age ), ( "id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.id ), ( "inviter_id", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.inviter_id ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildUser_stddev_order_by : (User_stddev_order_byOptionalFields -> User_stddev_order_byOptionalFields) -> User_stddev_order_by
buildUser_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_stddev_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_stddev\_order\_by input object.
-}
type alias User_stddev_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeUser_stddev_order_by : User_stddev_order_by -> Value
encodeUser_stddev_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_stddev_pop_order_by : (User_stddev_pop_order_byOptionalFields -> User_stddev_pop_order_byOptionalFields) -> User_stddev_pop_order_by
buildUser_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_stddev_pop_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_stddev\_pop\_order\_by input object.
-}
type alias User_stddev_pop_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUser_stddev_pop_order_by : User_stddev_pop_order_by -> Value
encodeUser_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_stddev_samp_order_by : (User_stddev_samp_order_byOptionalFields -> User_stddev_samp_order_byOptionalFields) -> User_stddev_samp_order_by
buildUser_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_stddev_samp_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_stddev\_samp\_order\_by input object.
-}
type alias User_stddev_samp_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUser_stddev_samp_order_by : User_stddev_samp_order_by -> Value
encodeUser_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_sum_order_by : (User_sum_order_byOptionalFields -> User_sum_order_byOptionalFields) -> User_sum_order_by
buildUser_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_sum_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_sum\_order\_by input object.
-}
type alias User_sum_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_sum\_order\_by into a value that can be used as an argument.
-}
encodeUser_sum_order_by : User_sum_order_by -> Value
encodeUser_sum_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_var_pop_order_by : (User_var_pop_order_byOptionalFields -> User_var_pop_order_byOptionalFields) -> User_var_pop_order_by
buildUser_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_var_pop_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_var\_pop\_order\_by input object.
-}
type alias User_var_pop_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeUser_var_pop_order_by : User_var_pop_order_by -> Value
encodeUser_var_pop_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_var_samp_order_by : (User_var_samp_order_byOptionalFields -> User_var_samp_order_byOptionalFields) -> User_var_samp_order_by
buildUser_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_var_samp_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_var\_samp\_order\_by input object.
-}
type alias User_var_samp_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeUser_var_samp_order_by : User_var_samp_order_by -> Value
encodeUser_var_samp_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUser_variance_order_by : (User_variance_order_byOptionalFields -> User_variance_order_byOptionalFields) -> User_variance_order_by
buildUser_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { age = Absent }
    in
    { age = optionals.age }


type alias User_variance_order_byOptionalFields =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Type for the User\_variance\_order\_by input object.
-}
type alias User_variance_order_by =
    { age : OptionalArgument Hasura.Enum.Order_by.Order_by }


{-| Encode a User\_variance\_order\_by into a value that can be used as an argument.
-}
encodeUser_variance_order_by : User_variance_order_by -> Value
encodeUser_variance_order_by input =
    Encode.maybeObject
        [ ( "age", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.age ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , in_ : OptionalArgument (List Hasura.ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List Hasura.ScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]
